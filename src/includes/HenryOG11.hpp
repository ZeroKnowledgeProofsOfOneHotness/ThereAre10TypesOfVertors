/*
 *Date: 2019/06/28
 *Project: Proof Of Concept for: There are 10 Types of Vectors (and Polynomials)
 *File: HenryOG11.hpp
 *  Contains Class and method declarations of data structures needed for (HV)ZKPoK for One-Hotness of a vector using an linear time OR proof
 */

#ifndef __BASIC_HPP__
#define __BASIC_HPP__
#include"utils.hpp"
#include"pedersen.hpp"

#include<NTL/ZZ_p.h>
#include<vector>
#include<tuple>
#include<chrono>
extern"C"{
    #include<relic/relic_core.h>
}

/* Class: ZKP_Prover_Or
 *
 * Can be used to run a OR proof of membership in a (HV)ZKPoK system.
 * This is a basic interface for using this protocol subject the following order of running:
 *  1)get_commitments
 *  2)set_challenge
 *  3)get_verification
 */
class ZKP_Prover_Or{
    private:
        Pedersen& P; //Reference to the universal Pedersen object. 
        Pedersen_Commitment C_d; //Commitment that is know, that you with to show has and opening in others
        vector<ZZ_p> others; //Array that you with to show membership
        vector<ZZ_p> V1,V2,V3,C; //Verification equations
        vector<Pedersen_Commitment> C1,A; //Commitments
        uint location;//The location in others, that the witness is located at.
    public:
        /* Method: Constructor
         *
         * Creates the object with the common knowledge and secret information that is needed to complete the proof. 
         * 
         * Petersen P: The singleton data structure used to create the Petersen_Commitments
         * Petersen_Commitment C_d: The commitment that will be proven to be in others,
         * vector<ZZ_p> others: The values that the opening of C_d is part of.
         * int location: the location inside of others where the witness if C_d is.
         */
        ZKP_Prover_Or(Pedersen& P,Pedersen_Commitment C_d,vector<ZZ_p> others,uint location);
        /* Method: Deconstructor
         *
         * Used to free all memory that is owned by this object
         */
        ~ZKP_Prover_Or();
        /* Method: get_commitments
         * 
         * This creates the inital commitments used in this sigma protocol,
         * 
         * Returns: vector<Pedersen_Commitments> that will be used by the verifier to confirm that C_D is correct.
         */
        vector<Pedersen_Commitment> get_commitments();
        /* Method: set_challenge
         *
         * Receive the challenge messene from the verifier to build the verification equations need by this protocol.
         * 
         * ZZ_p challenge: random number generated by the verifier
         */
        void set_challenge(ZZ_p challenge);
        /* Method: get_verification
         *
         * Generate the correct verification equations that would be needed by the verifier
         * 
         * Returns: tuple<vector<ZZ_p>,vector<ZZ_p>> 
         */
        tuple<vector<ZZ_p>,vector<ZZ_p>> get_verification();
};

/* Class: ZKP_Verifier_Or
 *
 * Can be used to run a OR proof of membership in a (HV)ZKPoK system.
 * This is a basic interface for using this protocol subject the following order of running:
 *  1)set_commitments
 *  2)get_challenge
 *  3)set_verification
 *  4)accept
 */
class ZKP_Verifier_Or{
    private:
        Pedersen& P; //Reference to the universal Pedersen object. 
        Pedersen_Commitment C_d; //The commitment that need to be verified, opens to something in others
        vector<ZZ_p> others; //Array that the opendings of C_d should be part of.
        vector<ZZ_p> V1,V2,V3,C;//verification equations
        vector<Pedersen_Commitment> A,C1; //Inital commitments from prover
        ZZ_p challenge;//Random value used for the challenge
    public:
        /* Method: Constructor
         *
         * This creates object that will be used to verify membership of C_d in others
         * 
         * Pedersen P: the singleton with contect understanding of g and h
         * Pedersen_Commitment C_d: The commitment in question
         * vector<ZZ_p> others: This should hold the openings of C_d
         */
        ZKP_Verifier_Or(Pedersen& P,Pedersen_Commitment C_d, vector<ZZ_p> others);

        /*Method: Deconstructor
         *
         * Frees any memory that this object might have had access to.
         */
        ~ZKP_Verifier_Or();

        /* Method: set_commitments
         *
         * This will set the inital commitment in to memory, for the object to eventually call accpet 
         */
        void set_commitments(vector<Pedersen_Commitment>);

        /* Method: get_challenge
         *
         * Samples a random value from the soundness of this protocol
         * 
         * Returns: the random challenge
         */
        ZZ_p get_challenge();

        /* Method: set_verification
         *
         * This will set the verification values into memory 
         */
        void set_verification(tuple<vector<ZZ_p>,vector<ZZ_p>>);

        /* Method: accept
         *
         * This will compute all the verification equations.
         * 
         * Return: true if and only if all equations pass.
         */
        bool accept();
};

/* Class: ZKP_Prover_Vector_HenryOG11
 * 
 * Responsible for running and mantianing the code for the (HV)ZKPoK a vector is one-hot
 * This is a basic interface for running the protocol subject to the order:
 *  1)set_vector_challenge
 *  2)get_commitments
 *  3)set_challenge
 *  4)get_verification
 */
class ZKP_Prover_Vector_HenryOG11{
    private:
        chrono::duration<double> creation_timer,set_vector_challenge_timer,get_commit_timer,set_challenge_timer,get_verify_timer;//Timeing code
        Pedersen& P;//The universal Pedersen object that has context of g and h
        vector<Pedersen_Commitment> Commitments; // The point wise commitment to a one hot vector
        uint location;//Location of the one
        vector<ZZ_p> arrChallenge;//This array will be point-wise dot product with Commitments
        ZKP_Prover_Or *prover;//Sub proof object

    public:
        /* Method: Constructor
         *
         *  Pedersen P: Has context of g, and h
         *  vector<Pedersen_Commitment> Commitments: the vector that will be proven
         *  int location: the location of the one
         */
        ZKP_Prover_Vector_HenryOG11(Pedersen& P,vector<Pedersen_Commitment> Commitments,uint location);

        /* Method: Deconstructor
         *
         * Frees any memory that the object might of held.
         */
        ~ZKP_Prover_Vector_HenryOG11();

        /* Method: set_vector_challenge
         *
         * Stores the vector challenge to be used when creating the initial commitments
         */
        void set_vector_challenge(vector<ZZ_p> arrChallenge);

        /* Method: get_commitment
         *
         * Runs the OR proof on C_d=commitments dot arrChallenge
         */
        vector<Pedersen_Commitment> get_commitments();

        /* Method: set_challenge
         *
         * Receives and set challenge to the sub protocol prover
         */
        void set_challenge(ZZ_p challenge);

        /* Method: get_verification
         *
         * Run the sub protocol prover
         * 
         * Returns the OR proofs verification equations
         */
        tuple<vector<ZZ_p>,vector<ZZ_p>> get_verification();

        /*Method: get_timers
         *
         * Timing Code
         */
        tuple<chrono::duration<double>,chrono::duration<double>,chrono::duration<double>,chrono::duration<double>,chrono::duration<double>> get_timers();
};

/* Class ZKP_Verifier_Vector_HenryOG11
 *
 * This is the verification class for this (HV)ZKPoK system
 * This interface is expected to be ran alongside the prover and subject to the following order
 *  1)get_vector_challenge
 *  2)set_commitments
 *  3)get_challenge
 *  4)set_verification
 *  5)accept
 */
class ZKP_Verifier_Vector_HenryOG11{
    private:
        chrono::duration<double> creation_timer,set_commit_timer,set_verify_timer,accept_timer;//Timing code
        Pedersen& P;//Universal Pedersen object, has context of g, and h
        vector<Pedersen_Commitment> Commitments; //Array that is verified to be a one-hot vector
        vector<ZZ_p> arrChallenge;//The vector of random values used to constuct a dot product
        ZKP_Verifier_Or *verifier;//Sub protocol system
        uint lambda;//Security parameter
    public:
        /* Method: Constructor
         *
         * Create verification object for this protocol to wrap the system into the logical steps
         * 
         * Pedersen P: The shared P that has the context of P
         * vector<Pedersen_Commitments> Commitments: the vector that will be proven to be a one hot vector
         * uint lambda: the security parameter range (1-256), possible to be bigger if larger curve is used
         */
        ZKP_Verifier_Vector_HenryOG11(Pedersen& P,vector<Pedersen_Commitment> Commitments,uint lambda);

        /* Method: Deconstructor
         *
         * This will free any memory used by this object
         */
        ~ZKP_Verifier_Vector_HenryOG11();

        /* Method: get_vector_challenge
         *
         * Creates a random vector that will be used to dot product with the commitment array
         * 
         * return: arrChallenge
         */
        vector<ZZ_p> get_vector_challenge();

        /* Method: set_commitments
         *
         * Sets the array of commitments in memory to be used for later
         */
        void set_commitments(vector<Pedersen_Commitment>);

        /* Method: get_challenge
         *
         * Uses the subprotocol verifier to get the challenge for the or proof
         *
         * return: random challenge
         */
        ZZ_p get_challenge();

        /* Method: set_verification
         *
         * Set the memory inside the subprotocol to be ran in accept later
         */
        void set_verification(tuple<vector<ZZ_p>,vector<ZZ_p>>);

        /* Method: accept
         *
         * runs the accept code inside of the subprotocol verifier
         * 
         * returns true if and only if subprotocol returns true
         */
        bool accept();

        /*Method: get_timers
         *
         * Timing code
         */
        tuple<chrono::duration<double>,chrono::duration<double>,chrono::duration<double>,chrono::duration<double>> get_timers();

};
#endif